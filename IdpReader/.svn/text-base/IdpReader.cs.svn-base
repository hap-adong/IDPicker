using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Runtime.InteropServices;
using System.Xml;
using System.Text.RegularExpressions;
using System.Net;
using System.Reflection;
using System.ComponentModel;
using pwiz.CLI.analysis;
using pwiz.CLI.data;
using pwiz.CLI.msdata;
using pwiz.CLI.proteome;
using SourceList = System.Collections.Generic.Set<IDPicker.SourceInfo>;



namespace IDPReader
{
    class IdpReader
    {
        //get pepSequence,source,scanID, write into a csv file. 
        //have tons of information: theretical ion intensity, pep info, chargeLabel...
        public static void idpReader(string idpXMLFile, string mzMLFile, double TicCutoffPercentage, int z)
        {
            //get the path and filename of output csv file:
            string fileName = Path.GetFileNameWithoutExtension(idpXMLFile);
            string filePath = Path.GetDirectoryName(idpXMLFile);
            string csvFile = Path.Combine(filePath, fileName) + "_" + z.ToString() + ".csv";
            

            IDPicker.Workspace workspace = new IDPicker.Workspace();
            Package.loadWorkspace(ref workspace, idpXMLFile);

            using (StreamWriter file = new StreamWriter(csvFile))
            {
                file.WriteLine("nativeID,pepSequence,basePeak,TIC,b1,b2,b3,y1,y2,y3,len,bond,NBasic,CBasic,NR,NK,NH,NL,CR,CK,CH,CL,R,K,H,L,ambiguityLabel");
                
                MSDataFile foo = new MSDataFile(mzMLFile);
                SpectrumList sl = foo.run.spectrumList;
                                    
                foreach (IDPicker.SourceGroupList.MapPair groupItr in workspace.groups)
                    foreach (IDPicker.SourceInfo source in groupItr.Value.getSources(true))
                        foreach (IDPicker.SpectrumList.MapPair sItr in source.spectra)
                        {

                            IDPicker.ResultInstance ri = sItr.Value.results[1];
                            IDPicker.VariantInfo vi = ri.info.peptides.Min;
                            
                            string ss = vi.ToString() + "," + sItr.Value.id.source.name + "," + sItr.Value.nativeID;
                            bool boolCharge = sItr.Value.id.charge.Equals(z);
                            if (boolCharge)
                            {
                                string rawPepSequence = vi.ToString();
                                string pepSequence = vi.peptide.sequence;
                                int len = pepSequence.Length;
                                
                                // Look up the index with nativeID
                                object idOrIndex = null;
                                if( sItr.Value.nativeID != null && sItr.Value.nativeID.Length > 0 )
                                    idOrIndex = sItr.Value.nativeID;
                                int spectrumIndex = sl.find(idOrIndex as string);
                                // Trust the local index, if the nativeID lookup fails
                                if( spectrumIndex >= sl.size() )
                                    spectrumIndex = sItr.Value.id.index;
                                // Bail of the loca index is larger than the spectrum list size
                                if( spectrumIndex >= sl.size() )
                                    throw new Exception( "Can't find spectrum associated with the index." );

                                Console.WriteLine(idOrIndex.ToString());
                                //get base peak and TIC and converted to string
                                Spectrum spec1 = sl.spectrum(spectrumIndex, true);
                                MZIntensityPairList peaks = new MZIntensityPairList();
                                spec1.getMZIntensityPairs(ref peaks);
                                Set<Peak> peakList = new Set<Peak>();
                                    
                                //get base peak and TIC
                                double basePeakValue = 0;
                                double TICValue = 0;
                                CVParamList list = spec1.cvParams;
                                foreach (CVParam CVP in list)
                                {
                                    if (CVP.name == "base peak intensity")
                                    {
                                        basePeakValue = CVP.value;
                                    }
                                    if (CVP.name == "total ion current")
                                    {
                                        TICValue = CVP.value;
                                    }
                                }
                                string basePeak = basePeakValue.ToString();
                                string TIC = TICValue.ToString();

                                //very important. Surendra put them here
                                //to change those with modifications {} into a format
                                //that fragment method will accept. 
                                string interpretation = vi.ToSimpleString();
                                    
                                Peptide peptide = new Peptide(interpretation, ModificationParsing.ModificationParsing_Auto, ModificationDelimiter.ModificationDelimiter_Brackets);
                                    
                                Fragmentation fragmentation = peptide.fragmentation(true, true);
                                //prepare the qualified peaklist
                                double intenThreshhold = 0;
                                int totalIntenClass = 0;

                                double[] intenArray = new double[peaks.Count];
                                //used during the foreach loop
                                int indexPeaks = 0;

                                //get all the peaks no matter how small they are
                                //then calculate the threshhold TIC
                                //test here
                                foreach (MZIntensityPair mzIntensity in peaks)
                                {
                                    //Peak p = new Peak(mzIntensity.mz, mzIntensity.intensity);
                                    //peakList.Add(p);
                                    intenArray[indexPeaks] = mzIntensity.intensity;
                                    indexPeaks++;
                                }
                                Array.Sort(intenArray);
                                Array.Reverse(intenArray, 0, peaks.Count);

                                //if currTIC>=cutoff, then break
                                double currTIC = 0;
                                double cutOffTIC = TicCutoffPercentage * TICValue;
                                foreach (double inten in intenArray)
                                {
                                    currTIC = currTIC + inten;
                                    if (currTIC < cutOffTIC)
                                    {
                                        intenThreshhold = inten;
                                        totalIntenClass++;
                                    }
                                    else break;
                                }


                                //then based on that, generate a new peaklist that contains only ABC peaks
                                //then calculate the intensity classes
                                foreach (MZIntensityPair mzIntensity in peaks)
                                {
                                    if (mzIntensity.intensity >= intenThreshhold)
                                    {
                                        Peak p = new Peak(mzIntensity.mz, mzIntensity.intensity);
                                        peakList.Add(p);
                                    }
                                }


                                //rowDic contains row information of each peptide bond
                                Dictionary<int, string> rowDic = new Dictionary<int, string>();
                                //intensityDic contains intensity information of fragment ions for each peptide bond
                                Dictionary<int, List<double>> intensityDic = new Dictionary<int, List<double>>();
                                //commonList contains the common intensities
                                List<double> duplicateList = new List<double>(); 

                                //call the method
                                List<double> completeIntensityList = new List<double>();
                                for (int k = 1; k < len; k++)
                                {
                                    List<double> intensityList = new List<double>();
                                    
                                    string bion = pepSequence.Substring(0, k);
                                    string yion = pepSequence.Substring(k, len - k);

                                    int NR = Package.parseAAResidues(bion, 'R');
                                    int NK = Package.parseAAResidues(bion, 'K');
                                    int NH = Package.parseAAResidues(bion, 'H');
                                    int NL = k;
                                    int CR = Package.parseAAResidues(yion, 'R');
                                    int CK = Package.parseAAResidues(yion, 'K');
                                    int CH = Package.parseAAResidues(yion, 'H');
                                    int CL = len - k;
                                    int R = NR - CR;
                                    int K = NK - CK;
                                    int H = NH - CH;
                                    int L = NL - CL;
                                    int pepBond = k;
                                    int NBasicAA = NR + NK + NH;
                                    int CBasicAA = CR + CK + CH;
                                    string AA = NBasicAA + "," + CBasicAA + "," + NR + "," + NK + "," + NH + "," + NL + "," + CR + "," + CK + "," + CH + "," + CL + "," + R + "," + K + "," + H + "," + L;


                                    double[] bCharge = new double[z + 1];
                                    double[] yCharge = new double[z + 1];
                                    double[] bIntensity = new double[z + 1];
                                    double[] yIntensity = new double[z + 1];
                                    string bIonIntensity = "";
                                    string yIonIntensity = "";
                                    //to judge if the sum of intensities are 0
                                    //so to exclude the case with all "0s"
                                    double sumIntensity = 0;

                                    //return the b ion charge 1 Intensity, if matched
                                    for (int i = 1; i <= z; i++)
                                    {
                                        bCharge[i] = fragmentation.b(k, i);
                                        yCharge[i] = fragmentation.y(len - k, i);
                                        Peak bmatched = Package.findClose(peakList, bCharge[i], 0.5);
                                        Peak ymatched = Package.findClose(peakList, yCharge[i], 0.5);
                                        if (bmatched != null) 
                                        {
                                            bIntensity[i] = bmatched.rankOrIntensity;
                                            intensityList.Add(bmatched.rankOrIntensity);
                                            completeIntensityList.Add(bmatched.rankOrIntensity);
                                        }
                                        else bIntensity[i] = 0;
                                        if (ymatched != null)
                                        { 
                                            yIntensity[i] = ymatched.rankOrIntensity;
                                            intensityList.Add(ymatched.rankOrIntensity);
                                            completeIntensityList.Add(ymatched.rankOrIntensity);
                                        }
                                        else yIntensity[i] = 0;

                                        sumIntensity = sumIntensity + bIntensity[i] + yIntensity[i];

                                        //record b/y ion intensity information into a string
                                        bIonIntensity = bIonIntensity + "," + bIntensity[i];
                                        yIonIntensity = yIonIntensity + "," + yIntensity[i];

                                    }

                                    intensityDic.Add(pepBond, intensityList);
                                    //to determine charge label, need to split by precursor charge
                                    //first need to make a metric to determine if all intensities are "0"

                                    if (z == 3)
                                    {
                                        if (sumIntensity != 0)
                                        {
                                            ////////////////////////////////////////////////
                                            //set the ambiguity label as follows:
                                            //-3: (0/+3) y3 only
                                            //-2: (0/+3, +1/+2) y3, b1y2
                                            //-1: (+1/+2): b1y2
                                            //0: (+1/+2, +2/+1): b1y2, b2y1
                                            //1: (+2/+1): b2y1
                                            //2: (+2/+1, +3/0): b2y1, b3
                                            //3: (+3/0): b3 only
                                            ////////////////////////////////////////////////
                                               
                                            double b1 = bIntensity[1];
                                            double b2 = bIntensity[2];
                                            double y1 = yIntensity[1];
                                            double y2 = yIntensity[2];
                                            double b3 = bIntensity[3];
                                            double y3 = yIntensity[3];
                                            double b1y2 = b1 + y2;
                                            double b2y1 = b2 + y1;
                                            string ambiguityLabel = "";
                                            //first part: set the intensity group: y3, b1y2, b2y1, b3
                                            //if one group was found, set the label
                                            //if two were found, but adjacent to each other, then ambiguity label is set
                                            if (y3 != 0 && (b1y2 + b2y1 + b3) == 0) ambiguityLabel = "-3";
                                            else if (y3 != 0 && b1y2 != 0 && (b2y1 + b3) == 0) ambiguityLabel = "-2";
                                            else if (b1y2 != 0 && (y3 + b2y1 + b3) == 0) ambiguityLabel = "-1";
                                            else if (b1y2 != 0 && b2y1 != 0 && (y3 + b3) == 0) ambiguityLabel = "0";
                                            else if (b2y1 != 0 && (y3 + b1y2 + b3) == 0) ambiguityLabel = "1";
                                            else if (b2y1 != 0 && b3 != 0 && (y3 + b1y2) == 0) ambiguityLabel = "2";
                                            else if (b3 != 0 && (y3 + b1y2 + b2y1) == 0) ambiguityLabel = "3";
                                            else ambiguityLabel = "error";
                                                
                                            string finalString = idOrIndex + "," + pepSequence + "," + basePeak + "," + TIC + bIonIntensity + yIonIntensity + "," + len + "," + pepBond + "," + AA + "," + ambiguityLabel;
                                            rowDic.Add(pepBond, finalString);
                                        }
                                    }
                                }//end for each peptide bond

                                //now we have: rowDic, intensityDic for each pep bond
                                //and we have: and completeIntensityList for each peptide
                                duplicateList = Package.findCommon(completeIntensityList);
                                foreach (int bond in rowDic.Keys)
                                {
                                    bool dup = true;
                                    foreach (double inten in duplicateList)
                                    {
                                        if (intensityDic[bond].Contains(inten))
                                        {
                                            dup = false;
                                            break;
                                        }
                                    }
                                    if (dup)
                                    {
                                        file.WriteLine(rowDic[bond]);
                                        Console.WriteLine("fragmente ion added");
                                    }
                                }

                            }//end if z==3
                        }//end foreach peptide
            }//end using
        }//end idpReader



        public static void Main(string[] args)
        {
            //for test of idpReader
            //string idpXMLFile_nm = "Z:\\home\\dwang\\complex10-12-10\\test\\test_nm.idpXML";
            //string idpXMLFile_pm = "Z:\\home\\dwang\\complex10-12-10\\test\\test_pm.idpXML";
            //string pepXMLFile_nm = "Z:\\home\\dwang\\complex10-12-10\\test\\test_nm.pepXML";
            //string pepXMLFile_pm = "Z:\\home\\dwang\\complex10-12-10\\test\\test_pm.pepXML";
            //string mzMLFile = "Z:\\home\\dwang\\complex10-12-10\\test\\test.mzML";
            //string model_nm = "nm";
            //string model_pm = "pm";
            //idpReader(idpXMLFile_nm, mzMLFile, 0.95, 3);

            //idpReader   
            //Console.WriteLine("for orbi format: idpReader <idpxml> <mzML>");
            //idpReader(args[0], args[1], 0.98, 3);
        }

    }//end IdpReader
}
